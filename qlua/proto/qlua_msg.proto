syntax = "proto3";

enum ProcedureType {

    PROCEDURE_TYPE_UNKNOWN = 0;
    IS_CONNECTED = 1;
    GET_SCRIPT_PATH = 2;
    GET_INFO_PARAM = 3;
    MESSAGE = 4;
    SLEEP = 5;
    GET_WORKING_FOLDER = 6;
    PRINT_DBG_STR = 7;
    GET_ITEM = 8;
    GET_ORDER_BY_NUMBER = 9; // NOT TESTED YET
    GET_NUMBER_OF = 10;
    SEARCH_ITEMS = 11;
    GET_CLASSES_LIST = 12;
    GET_CLASS_INFO = 13;
    GET_CLASS_SECURITIES = 14;
    GET_MONEY = 15;
    GET_MONEY_EX = 16;
    GET_DEPO = 17;
    GET_DEPO_EX = 18;
    GET_FUTURES_LIMIT = 19;
    GET_FUTURES_HOLDING = 20;
    GET_SECURITY_INFO = 21;
    GET_TRADE_DATE = 22;
    GET_QUOTE_LEVEL2 = 23;
    
    GET_LINES_COUNT = 24;
    GET_NUM_CANDLES = 25;
    GET_CANDLES_BY_INDEX = 26;
    
    CREATE_DATA_SOURCE = 27;
    DS_SET_UPDATE_CALLBACK = 28;
    DS_O = 29;
    DS_H = 30;
    DS_L = 31;
    DS_C = 32;
    DS_V = 33;
    DS_T = 34;
    DS_SIZE = 35;
    DS_CLOSE = 36;
    DS_SET_EMPTY_CALLBACK = 37;
    
    SEND_TRANSACTION = 38;
    CALC_BUY_SELL = 39; // NOT TESTED YET
    
    GET_PARAM_EX = 40;
    GET_PARAM_EX_2 = 41; // NB: использовать структуры запроса и ответа от GET_PARAM_EX
    
    GET_PORTFOLIO_INFO = 42;
    GET_PORTFOLIO_INFO_EX = 43;
    
    GET_BUY_SELL_INFO = 44;
    GET_BUY_SELL_INFO_EX = 45; // NB: использовать структуры запроса и ответа от GET_BUY_SELL_INFO
    
    ADD_COLUMN = 46; // нужно бы ещё потестить, т.к. после добавления одного столбца другие добавляются, но визуально не отображаются
    ALLOC_TABLE = 47;
    CLEAR = 48;
    CREATE_WINDOW = 49;
    DELETE_ROW = 50;
    DESTROY_TABLE = 51;
    INSERT_ROW = 52; // NB: использовать после создания окна для таблицы (процедура CREATE_WINDOW)
    IS_WINDOW_CLOSED = 53;
    GET_CELL = 54;
    GET_TABLE_SIZE = 55;
    GET_WINDOW_CAPTION = 56;
    GET_WINDOW_RECT = 57;
    SET_CELL = 58;
    SET_WINDOW_CAPTION = 59;
    SET_WINDOW_POS = 60;
    SET_TABLE_NOTIFICATION_CALLBACK = 61;
    RGB = 62; // NB: на самом деле, библиотечная функция RGB должна называться BGR, ибо она выдаёт числа именно в этом формате. В SetColor, однако, тоже ожидается цвет в формате BGR, так что это не баг, а фича.
    SET_COLOR = 63;
    HIGHLIGHT = 64;
    SET_SELECTED_ROW = 65;

    ADD_LABEL = 66; // NOT IMPLEMENTED YET
    DEL_LABEL = 67; // NOT IMPLEMENTED YET
    DEL_ALL_LABELS = 68; // NOT IMPLEMENTED YET
    GET_LABEL_PARAMS = 69; // NOT IMPLEMENTED YET
    SET_LABEL_PARAMS = 70; // NOT IMPLEMENTED YET
    
    SUBSCRIBE_LEVEL_II_QUOTES = 71; // NOT IMPLEMENTED YET
    UNSUBSCRIBE_LEVEL_II_QUOTES = 72; // NOT IMPLEMENTED YET
    IS_SUBSCRIBED_LEVEL_II_QUOTES = 73; // NOT IMPLEMENTED YET
    
    PARAM_REQUEST = 74; // NOT IMPLEMENTED YET
    CANCEL_PARAM_REQUEST = 75; // NOT IMPLEMENTED YET
}

enum EventType {

    EVENT_TYPE_UNKNOWN = 0;
    PUBLISHER_ONLINE = 1; // no data attached
    PUBLISHER_OFFLINE = 2; // no data attached
    ON_CLOSE = 3; // no data attached
    ON_CONNECTED = 4; // no data attached
    ON_DISCONNECTED = 5; // no data attached
    ON_FIRM = 6; // data attached as StringStringTable
    ON_ALL_TRADE = 7; // data attached as StringStringTable
    ON_TRADE = 8; // data attached as StringStringTable
    ON_ORDER = 9; // data attached as StringStringTable
    ON_ACCOUNT_BALANCE = 10; // data attached as StringStringTable
    ON_FUTURES_LIMIT_CHANGE = 11; // data attached as StringStringTable
    ON_FUTURES_LIMIT_DELETE = 12; // data attached as StringStringTable
    ON_FUTURES_CLIENT_HOLDING = 13; // data attached as StringStringTable
    ON_MONEY_LIMIT = 14; // data attached as StringStringTable
    ON_MONEY_LIMIT_DELETE = 15; // data attached as StringStringTable
    ON_DEPO_LIMIT = 16; // data attached as StringStringTable
    ON_DEPO_LIMIT_DELETE = 17; // data attached as StringStringTable
    ON_ACCOUNT_POSITION = 18; // data attached as StringStringTable
    ON_NEG_DEAL = 19; // data attached as StringStringTable
    ON_NEG_TRADE = 20; // data attached as StringStringTable
    ON_STOP_ORDER = 21; // data attached as StringStringTable
    ON_TRANS_REPLY = 22; // data attached as StringStringTable
    ON_PARAM = 23; // data attached as StringStringTable
    ON_QUOTE = 24; // data attached as StringStringTable
    ON_CLEAN_UP = 25; // no data attached
}

// Не получилось внедрить это определение в AddColumn_Request, т.к. не смог потом залукапить значения енама
enum ColumnParameterType {

    COLUMN_PARAMETER_TYPE_UNKNOWN = 0;
    QTABLE_INT_TYPE = 1;
    QTABLE_DOUBLE_TYPE = 2;
    QTABLE_INT64_TYPE = 3;
    QTABLE_CACHED_STRING_TYPE = 4;
    QTABLE_TIME_TYPE = 5;
    QTABLE_DATE_TYPE = 6;
    QTABLE_STRING_TYPE = 7;
}

enum Interval {

    INTERVAL_UNKNOWN = 0;
    INTERVAL_TICK = 1;
    INTERVAL_M1 = 2;
    INTERVAL_M2 = 3;
    INTERVAL_M3 = 4;
    INTERVAL_M4 = 5;
    INTERVAL_M5 = 6;
    INTERVAL_M6 = 7;
    INTERVAL_M10 = 8;
    INTERVAL_M15 = 9;
    INTERVAL_M20 = 10;
    INTERVAL_M30 = 11;
    INTERVAL_H1 = 12;
    INTERVAL_H2 = 13;
    INTERVAL_H4 = 14;
    INTERVAL_D1 = 15;
    INTERVAL_W1 = 16;
    INTERVAL_MN1 = 17;
}

enum MessageIconType {

    MESSAGE_ICON_TYPE_UNDEFINED = 0;
    MESSAGE_ICON_TYPE_INFO = 1;
    MESSAGE_ICON_TYPE_WARNING = 2;
    MESSAGE_ICON_TYPE_ERROR = 3;
}

message TableEntry {

    string k = 1;
    string v = 2;
}

message CandleEntry {

    string open = 1;
    string close = 2;
    string high = 3;
    string low = 4;
    string volume = 5;
    int32 does_exist = 6;
    DateTimeEntry datetime = 7;
}

message DateTimeEntry {

    string mcs = 1; // not sure if it's integral, so leave it be string until figured out
    string ms = 2; // not sure if it's integral, so leave it be string until figured out
    int32 sec = 3;
    int32 min = 4;
    int32 hour = 5;
    int32 day = 6;
    int32 week_day = 7;
    int32 month = 8;
    int32 year = 9;
}

message StringStringTable {
    map<string, string> kv = 1;
}

message Qlua_Request {

    ProcedureType type = 2;
    bytes args = 3; // the protoc-lua-plugin gives out a corrupted .lua file if we use google.protobuf.Any
}

message Qlua_Response {

    ProcedureType type = 1;
    bool is_error = 2;
    bytes result = 3;
  
    // Если это внутренняя ошибка RPC-сервиса, то установлен is_error,
    // в противном случае -- установлен result (даже если он содержит в себе
    // ошибку от библиотеки qlua). Таким образом, ошибки, возвращаемые библиотекой 
    // qlua (например, nil в определённых случаях), в рамках RPC-сервиса 
    // являются обычным результатом выполнения запроса.
}

message Qlua_Event {

    EventType type = 1;
    bytes data = 2;
}

message IsConnected_Result {
    int32 is_connected = 1;
}

message GetScriptPath_Result {
    string script_path = 1;
}

message GetInfoParam_Request {

    // Хотел сделать enum-ом, чтобы меньше слать по wire, но в используемой Lua-реализации
    // protobuf'a нет адекватного способа вернуть строковое имя enum'а, поэтому говнокод, который
    // надо будет для этого написать, скорее всего нивелирует какой-либо перфомансный 
    // профит от enum'ов в данном случае. К тому же, при добавлении новых видов paramName 
    // при использовании строк ничего не надо будет перекомпилировать.
    string param_name = 1;  
}

message GetInfoParam_Result {
    string info_param = 1;
}

message Message_Request {

    string message = 1;
    MessageIconType icon_type = 2;
}

message Message_Result {
    int32 result = 1;
}

message Sleep_Request {
    int32 time = 1;
}

message Sleep_Result {
    int32 result = 1;
}

message GetWorkingFolder_Result {
    string working_folder = 1;
}

message PrintDbgStr_Request {
    string s = 1;
}

message GetItem_Request {

    string table_name = 1;
    double index = 2;
}

message GetItem_Result {
    map<string, string> table_row = 1;
}

message GetOrderByNumber_Request {

    string class_code = 1;
    uint32 order_id = 2;
}

message GetOrderByNumber_Result {

    repeated TableEntry order = 1;
    int32 indx = 2;
}

message GetNumberOf_Request {
    string table_name = 1;
}

message GetNumberOf_Result {
    int32 result = 1;
}

message SearchItems_Request {

    string table_name = 1;
    int32 start_index = 2;
    
    // Для удобства 0 интерпретируется как getNumberOf(table_name) - 1
    int32 end_index = 3; 
    
    // Формат функции без использования params: "function (TABLE t) ... end", возвращаемые значения: BOOLEAN, nil; 
    // где t -- строка таблицы table_name со всеми параметрами.
    // Формат функции при использовании params: "function (p1, p2, ...) ... end", возвращаемые значения: BOOLEAN, nil; 
    // где p1, p2, ... -- значения параметров, заказанных в params
    
    // Внимание! По результам тестирования возврат nil из fn не приводит к ожидаемому результату (возврат списка уже пройденных индексов, удовлетворяющих условию + индекс, на котором возвратили nil + остановка процесса проверки условия) -- вместо этого процесс проверки условия прерывается и функция SearchItems возвращает nil. Подозреваю, что это баг в QLUA или ошибка в документации.
    string fn_def = 4; 
    
    string params = 5;
}

message SearchItems_Result {
    repeated int32 items_indices = 1; 
    //NB: Недоработка QLUA: пустой список индексов возвращается в виде nil, и ошибка при работе фукнции проверки элемента (fn)
    //тоже приводит к возврату nil, так что непонятно, не нашли ли мы удовлетворяющих условию элементов или написали ошибочную
    //функцию проверки условия. Для определённости, в обоих случаях будем возвращать пустой список.--]]
}

message GetClassesList_Result {
    string classes_list = 1;
}

message GetClassInfo_Request {
    string class_code = 1;
}

message GetClassInfo_Result {
    map<string, string> class_info = 1;
}

message GetClassSecurities_Request {
    string class_code = 1;
}

message GetClassSecurities_Result {
    string class_securities = 1;
}

message GetMoney_Request {

    string client_code = 1; // Код клиента
    string firmid = 2; // Фирма
    string tag = 3; // Группа
    string currcode = 4; // Валюта
}

message GetMoney_Result {
    map<string, string> money = 1;
}

message GetMoneyEx_Request {

    string firmid = 1; // Фирма
    string client_code = 2; // Код клиента
    string tag = 3; // Группа
    string currcode = 4; // Валюта
    int32 limit_kind = 5; // Вид лимита (Как задать лимит "Tx"? Ответ: видимо, никак -- это недоработка в API qlua)
}

message GetMoneyEx_Result {
    map<string, string> money_ex = 1;
}

message GetDepo_Request {

    string client_code = 1; // Код клиента
    string firmid = 2; // Фирма
    string sec_code = 3; // Код бумаги
    string trdaccid = 4; // Счет депо
}

message GetDepo_Result {
    map<string, string> depo = 1;
}

message GetDepoEx_Request {

    string firmid = 1; // Фирма
    string client_code = 2; // Код клиента
    string sec_code = 3; // Код бумаги
    string trdaccid = 4; // Счет депо
    int32 limit_kind = 5; // Вид лимита (Как задать лимит "Tx"? Ответ: видимо, никак -- это недоработка в API qlua)
}

message GetDepoEx_Result {
    map<string, string> depo_ex = 1;
}

message GetFuturesLimit_Request {

    string firmid = 1;
    string trdaccid = 2;
    int32 limit_type = 3;
    string currcode = 4;
}

message GetFuturesLimit_Result {
    map<string, string> futures_limit = 1;
}

message GetFuturesHolding_Request {

    string firmid = 1;
    string trdaccid = 2;
    string sec_code = 3;
    int32 type = 4;
}

message GetFuturesHolding_Result {
    map<string, string> futures_holding = 1;
}

message GetSecurityInfo_Request {

    string class_code = 1;
    string sec_code = 2;
}

message GetSecurityInfo_Result {
    map<string, string> security_info = 1;
}

message GetTradeDate_Result {
    map<string, string> trade_date = 1;
}

message GetQuoteLevel2_Request {

    string class_code = 1;
    string sec_code = 2;
}

message GetQuoteLevel2_Result {

    message QuoteEntry {
    
        string price = 1;
        string quantity = 2;
    }

    string bid_count = 1;
    string offer_count = 2;
    repeated QuoteEntry bid = 3;
    repeated QuoteEntry offer = 4;
}

message GetLinesCount_Request {
    string tag = 1;
}

message GetLinesCount_Result {
    int32 lines_count = 1;
}

message GetNumCandles_Request {
    string tag = 1;
}

message GetNumCandles_Result {
    int32 num_candles = 1;
}

message GetCandlesByIndex_Request {

    string tag = 1;
    int32 line = 2;
    int32 first_candle = 3;
    int32 count = 4;
}

message GetCandlesByIndex_Result {

    repeated CandleEntry t = 1;
    int32 n = 2;
    string l = 3;
}

message CreateDataSource_Request {

    string class_code = 1;
    string sec_code = 2;
    Interval interval = 3;
    string param = 4;
}

message CreateDataSource_Result {

    string datasource_uuid = 1; 
    bool is_error = 2;
    string error_desc = 3;
}

message DataSourceSetUpdateCallback_Request {

    string datasource_uuid = 1; 
    string f_cb_def = 2; // NB: формат функции: "function (NUMBER index, TABLE datasource) function_body end"
}

message DataSourceSetUpdateCallback_Result {
    bool result = 1;
}

message DataSourceO_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceO_Result {
    double value = 1; // use of double for money representation!
}

message DataSourceH_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceH_Result {
    double value = 1; // use of double for money representation!
}

message DataSourceL_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceL_Result {
    double value = 1; // use of double for money representation!
}

message DataSourceC_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceC_Result {
    double value = 1; // use of double for money representation!
}

message DataSourceV_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceV_Result {
    double value = 1; // use of double for money representation!
}

message DataSourceT_Request {

    string datasource_uuid = 1;
    int32 candle_index = 2;
}

message DataSourceT_Result {

    int32 year = 1;
    int32 month = 2;
    int32 day = 3;
    int32 week_day = 4;
    int32 hour = 5;
    int32 min = 6;
    int32 sec = 7;
    int32 ms = 8;
    int32 count = 9;
}

message DataSourceSize_Request {
    string datasource_uuid = 1;
}

message DataSourceSize_Result {
    int32 value = 1;
}

message DataSourceClose_Request {
    string datasource_uuid = 1;
}

message DataSourceClose_Result {
    bool result = 1;
}

message DataSourceSetEmptyCallback_Request {
    string datasource_uuid = 1;
}

message DataSourceSetEmptyCallback_Result {
    bool result = 1;
}

message SendTransaction_Request {
    map<string, string> transaction = 1;
}

message SendTransaction_Result {
    string result = 1;
}

message CalcBuySell_Request {

    string class_code = 1;
    string sec_code = 2;
    string client_code = 3;
    string account = 4;
    double price = 5;
    bool is_buy = 6;
    bool is_market = 7;
}

message CalcBuySell_Result {

    int32 qty = 1;
    double comission = 2; // use of double for money?
}

message GetParamEx_Request {

    string class_code = 1;
    string sec_code = 2;
    string param_name = 3; // возможные значения для этого параметра можно найти тут: https://quikluacsharp.ru/quik-qlua/poluchenie-dannyh-iz-tablits-quik-v-qlua-lua/
}

message GetParamEx_Result {
    map<string, string> param_ex = 1;
}

message GetPortfolioInfo_Request {

    string firm_id = 1;
    string client_code = 2;
}

message GetPortfolioInfo_Result {
    map<string, string> portfolio_info = 1;
}

message GetPortfolioInfoEx_Request {

    string firm_id = 1;
    string client_code = 2;
    int32 limit_kind = 3;
}

message GetPortfolioInfoEx_Result {
    map<string, string> portfolio_info_ex = 1;
}

message GetBuySellInfo_Request {

    string firm_id = 1;
    string client_code = 2;
    string class_code = 3;
    string sec_code = 4;
    double price = 5;
}

message GetBuySellInfo_Result {
    map<string, string> buy_sell_info = 1;
}

// Важно! Это не указано в документации к Quik:
// добавлять столбцы нужно перед вызовом CreateWindow для указанной таблице. Иначе потом
// вызовы AddColumn будут возвращать ответ, что столбец добавлен, но визуально ничего не изменится.
// Я даже пробовал скрывать таблицу и создавать новое окно для неё, но всё равно добавленные 
// между делом столбцы не отобразились.
message AddColumn_Request {

    int32 t_id = 1;
    int32 icode = 2;
    string name = 3;
    bool is_default = 4;
    ColumnParameterType par_type = 5;
    int32 width = 6;
}

message AddColumn_Result {
    int32 result = 1;
}

message AllocTable_Result {
    int32 t_id = 1;
}

message Clear_Request {
    int32 t_id = 1;
}

message Clear_Result {
    bool result = 1;
}

message CreateWindow_Request {
    int32 t_id = 1;
}

message CreateWindow_Result {
    int32 result = 1;
}

message DeleteRow_Request {

    int32 t_id = 1;
    int32 key = 2;
}

message DeleteRow_Result {
    bool result = 1;
}

message DestroyTable_Request {
    int32 t_id = 1;
}

message DestroyTable_Result {
    bool result = 1;
}

message InsertRow_Request {

    int32 t_id = 1;
    sint32 key = 2;
}

message InsertRow_Result {
    sint32 result = 1;
}

message IsWindowClosed_Request {
    int32 t_id = 1;
}

message IsWindowClosed_Result {
    bool result = 1;
}

message GetCell_Request {

    int32 t_id = 1;
    int32 key = 2;
    int32 code = 3;
}

message GetCell_Result {

    string image = 1;
    string value = 2; // the parsing is left to be done on the client side, the library returns it as 0 if the cell's number is not set, so "0" goes on the wire in that case
}

message SetCell_Request {

    int32 t_id = 1;
    int32 key = 2;
    int32 code = 3;
    string text = 4;
    string value = 5;
}

message SetCell_Result {
    bool result = 1;
}

message SetWindowCaption_Request {

    int32 t_id = 1;
    string str = 2;
}

message SetWindowCaption_Result {
    bool result = 1;
}

message SetWindowPos_Request {

    int32 t_id = 1;
    sint32 x = 2;
    sint32 y = 3;
    sint32 dx = 4;
    sint32 dy = 5;
}

message SetWindowPos_Result {
    bool result = 1;
}

message SetTableNotificationCallback_Request {

    int32 t_id = 1;
    string f_cb_def = 2;
}

message SetTableNotificationCallback_Result {
    int32 result = 1;
}

message GetTableSize_Request {
    int32 t_id = 1;
}

message GetTableSize_Result {

    int32 rows = 1;
    int32 col = 2;
}

message GetWindowCaption_Request {
    int32 t_id = 1;
}

message GetWindowCaption_Result {
    string caption = 1;
}

message GetWindowRect_Request {
    int32 t_id = 1;
}

message GetWindowRect_Result {

    sint32 top = 1;
    sint32 left = 2;
    sint32 bottom = 3;
    sint32 right = 4;
}

// NB: на самом деле, библиотечная функция RGB должна называться BGR, ибо она выдаёт числа именно в этом формате. В SetColor, однако, тоже ожидается цвет в формате BGR, так что это не баг, а фича.
message RGB_Request {

    int32 red = 1;
    int32 green = 2;
    int32 blue = 3;
}

message RGB_Result {
    int32 result = 1;
}

message SetColor_Request {

    int32 t_id = 1;
    sint32 row = 2;
    sint32 col = 3;
    int32 b_color = 4;
    int32 f_color = 5;
    int32 sel_b_color = 6;
    int32 sel_f_color = 7;
}

message SetColor_Result {
    bool result = 1;
}

message Highlight_Request {

    int32 t_id = 1;
    sint32 row = 2;
    sint32 col = 3;
    int32 b_color = 4;
    int32 f_color = 5;
    int64 timeout = 6;
}

message Highlight_Result {
    bool result = 1;
}

message SetSelectedRow_Request {

    int32 table_id = 1;
    sint32 row = 2;
}

message SetSelectedRow_Result {
    sint32 result = 1;
}
